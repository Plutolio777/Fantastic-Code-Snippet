# 退避算法合集

## 引言：为什么我们需要退避算法？  

在现代分布式系统和网络通信中，**失败是常态而非例外**。无论是微服务间的RPC调用、数据库访问，还是客户端与API服务器的交互，短暂的网络抖动、资源竞争或服务过载都可能导致请求失败。面对这种不确定性，开发者最直觉的反应可能是——**立即重试**。但简单粗暴的重试策略往往会引发更严重的问题：  

### 1. 立即重试的致命缺陷  

- **重试风暴（Retry Storm）**：当服务短暂不可用时，大量客户端同时重试，形成"雪崩效应"  

  ```text
  示例场景：
  服务A因负载过高返回503 → 1000个客户端同时收到错误 → 所有客户端立即重试 → 服务A彻底崩溃
  ```

- **资源浪费**：无效的重试消耗客户端和服务端的CPU/连接池等资源  
- **放大故障**：可能将局部故障扩散到整个系统（如数据库连接池被重试请求耗尽）  

### 2. 现实世界的教训  

- **AWS服务中断事件**（2015）：由于缺少退避机制，S3服务的部分故障被客户端的持续重试放大为全局瘫痪  
- **Kubernetes控制器**：默认采用指数退避策略处理Pod创建失败，避免集群控制平面过载  

### 3. 退避算法的核心价值  

通过**有策略的等待**，退避算法在以下维度实现平衡：  

| 维度         | 立即重试的问题              | 退避算法的解决方案          |
|--------------|---------------------------|---------------------------|
| 系统压力     | 集中爆发                  | 分散请求                  |
| 故障恢复     | 干扰恢复过程              | 预留恢复时间窗口          |
| 资源利用率   | 无效占用                  | 智能调度                  |
| 公平性       | 先到者独占资源            | 随机化避免饥饿            |

## 指数退避（Exponential Backoff）

在分布式系统中，指数退避是最广泛采用的退避策略之一，其核心思想是让重试间隔随时间呈指数增长，从而快速降低对故障系统的压力。

### 算法原理

```text
delay = min(
    max_backoff, 
    min_backoff * 2^retry_attempt
)
```

实际实现中通常会加入随机抖动（Jitter），避免客户端同步重试。

以下是go-redis客户端库中的经典实现（带随机抖动和边界控制）：

```golang
func RetryBackoff(retry int, minBackoff, maxBackoff time.Duration) time.Duration {
    if retry < 0 {
        panic("not reached")
    }
    if minBackoff == 0 {
        return 0
    }

    // 指数计算基础值
    d := minBackoff << uint(retry)
    if d < minBackoff { // 溢出检查
        return maxBackoff
    }

    // 添加随机抖动（范围：[minBackoff, d)）
    d = minBackoff + time.Duration(rand.Int63n(int64(d)))

    // 边界保护
    if d > maxBackoff || d < minBackoff {
        d = maxBackoff
    }
    return d
}
```
